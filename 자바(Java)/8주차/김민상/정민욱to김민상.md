## 📌 CS 스터디 피드백 (2025-04-02)

### 1. 보완하면 좋을 질문 📝

#### ✅ HashMap의 resize()에 대해 설명해주세요.(재해싱)
Java는 LoadFactor를 넘어서게 되면 bucket의 사이즈를 키우게됩니다.
bucket의 사이즈는 해싱 알고리즘에 사용됩니다.(index최대 크기에 맞추기 위해)

따라서 resize()가 일어날 때 원래 원소도 재배치가 이뤄져야 합니다. 해당 부분에 대해서 조금 찾아보시면 좋을거 같습니다.

#### ✅ hashCode()를 오버라이딩할 때, 31이라는 매직 넘버가 자주 등장하는데 그 이유를 아시나요?
민상님 블로그에 작성되어 있던 내용이라서 여쭤봤던 지엽적인 내용입니다. HashMap이 자주 나오는 주제다 보니 면접관님도 해당 게시물을 훑어볼 수 있을 거 같아 한번 복습해보시면 좋을거 같습니다.

#### ✅ happen before guarantee에 대해 들어보셨나요?
Compiler는 java의 성능을 올리기 위해 여러 최적화가 들어갑니다.
그 최적화 과정 때문에 코드의 처리 순서가 저희가 작성한 것과는 조금 다를 수 있습니다.

volatile keyword가 붙은 변수에 연산이 가해지면 처리순서 최적화에 영향을 줍니다. 이전 코드가 무조건 다 실행된 후에 volatile에 연산이 이뤄지는 방식으로요.
또한, volatile keyword가 붙은 변수만 메모리로 데이터가 flush되고 메모리에서 데이터를 읽어오는게 아니라 해당 영역에 있는 모든 변수는 volatile키워드가 붙은 것 처럼 동작합니다. happen before guarantee를 지키기 위해서요.

#### ✅ synchronized를 이용해보신 적이 있을까요?
전체적으로 잘 답변해주셨지만 Atomic keyword와 synchronized keyword가 적합한 상황에 대해 고민해보시면 좋을거 같습니다.
CAS 알고리즘의 동작 방식에 기반하여 각각이 어떤 상황에서 더 이점이 있을지에 대해서 고민해보시면 좋을거 같습니다.
또 제가 추측하기로 volatile도 필요했을 수 있을 거 같은데 이것도 언급하셨으면 더 좋았을 거 같습니다.

### 2. 좋았던 점 ✨
- 지엽적인 질문 외에는 모두 답변하신거 같습니다. 특히, HashMap에 대해서 상당히 깊게 알고 계신 점이 인상깊었습니다.

### 3. 보완하면 좋을 점 💡
- 블로그에 작성된 내용을 모르면 감점이 있을 것 같습니다. 면접 전에 한번씩 복습하고 가시면 좋을 거 같아요.
